// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BattleEnum.proto

#ifndef PROTOBUF_BattleEnum_2eproto__INCLUDED
#define PROTOBUF_BattleEnum_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
namespace NetProto {
}  // namespace NetProto

namespace NetProto {

namespace protobuf_BattleEnum_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_BattleEnum_2eproto

enum ESceneObject {
  Building = 0,
  Hero = 1,
  Npc = 2,
  MAX = 3,
  ESceneObject_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ESceneObject_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ESceneObject_IsValid(int value);
const ESceneObject ESceneObject_MIN = Building;
const ESceneObject ESceneObject_MAX = MAX;
const int ESceneObject_ARRAYSIZE = ESceneObject_MAX + 1;

const ::google::protobuf::EnumDescriptor* ESceneObject_descriptor();
inline const ::std::string& ESceneObject_Name(ESceneObject value) {
  return ::google::protobuf::internal::NameOfEnum(
    ESceneObject_descriptor(), value);
}
inline bool ESceneObject_Parse(
    const ::std::string& name, ESceneObject* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ESceneObject>(
    ESceneObject_descriptor(), name, value);
}
enum EMoveAgentState {
  EMoveAgentState_Idle = 0,
  EMoveAgentState_MoveToPos = 1,
  EMoveAgentState_MoveToDir = 2,
  EMoveAgentState_Immobilized = 3,
  EMoveAgentState_ForceLine = 4,
  EMoveAgentState_ForcePos = 5,
  EMoveAgentState_Max = 6,
  EMoveAgentState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EMoveAgentState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EMoveAgentState_IsValid(int value);
const EMoveAgentState EMoveAgentState_MIN = EMoveAgentState_Idle;
const EMoveAgentState EMoveAgentState_MAX = EMoveAgentState_Max;
const int EMoveAgentState_ARRAYSIZE = EMoveAgentState_MAX + 1;

const ::google::protobuf::EnumDescriptor* EMoveAgentState_descriptor();
inline const ::std::string& EMoveAgentState_Name(EMoveAgentState value) {
  return ::google::protobuf::internal::NameOfEnum(
    EMoveAgentState_descriptor(), value);
}
inline bool EMoveAgentState_Parse(
    const ::std::string& name, EMoveAgentState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMoveAgentState>(
    EMoveAgentState_descriptor(), name, value);
}
enum EMoveState {
  EMoveState_Idle = 0,
  EMoveState_Move = 1,
  EMoveState_Immobilized = 2,
  EMoveState_ForceMove = 3,
  EMoveState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EMoveState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EMoveState_IsValid(int value);
const EMoveState EMoveState_MIN = EMoveState_Idle;
const EMoveState EMoveState_MAX = EMoveState_ForceMove;
const int EMoveState_ARRAYSIZE = EMoveState_MAX + 1;

const ::google::protobuf::EnumDescriptor* EMoveState_descriptor();
inline const ::std::string& EMoveState_Name(EMoveState value) {
  return ::google::protobuf::internal::NameOfEnum(
    EMoveState_descriptor(), value);
}
inline bool EMoveState_Parse(
    const ::std::string& name, EMoveState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMoveState>(
    EMoveState_descriptor(), name, value);
}
enum EBattleOperation {
  EBO_Invalid = 0,
  EBO_Stop = 1,
  EBO_Move = 2,
  EBO_Follow = 3,
  EBO_Hunt = 4,
  EBO_CastSkill_Q = 11,
  EBO_CastSkill_W = 12,
  EBO_CastSkill_E = 13,
  EBO_CastSkill_R = 14,
  EBO_CastSkill_F = 15,
  EBO_CastSkill_G = 16,
  EBO_UseItemSolt_1 = 21,
  EBO_UseItemSolt_2 = 22,
  EBO_UseItemSolt_3 = 23,
  EBO_UseItemSolt_4 = 24,
  EBO_UseItemSolt_5 = 25,
  EBO_UseItemSolt_6 = 26,
  EBO_MaxCount = 32,
  EBattleOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EBattleOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EBattleOperation_IsValid(int value);
const EBattleOperation EBattleOperation_MIN = EBO_Invalid;
const EBattleOperation EBattleOperation_MAX = EBO_MaxCount;
const int EBattleOperation_ARRAYSIZE = EBattleOperation_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBattleOperation_descriptor();
inline const ::std::string& EBattleOperation_Name(EBattleOperation value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBattleOperation_descriptor(), value);
}
inline bool EBattleOperation_Parse(
    const ::std::string& name, EBattleOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBattleOperation>(
    EBattleOperation_descriptor(), name, value);
}
enum EFightParam {
  EFP_None = 0,
  EFP_CurrHP = 1,
  EFP_MaxHP = 2,
  EFP_CurrMP = 3,
  EFP_MaxMP = 4,
  EFP_MoveSpeed = 7,
  EFP_AttackDist = 8,
  EFP_AttackSpeed = 9,
  EFP_Dizziness = 10,
  EFP_Silence = 11,
  EFP_Blind = 12,
  EFP_Immobilized = 13,
  EFP_PhyAttack = 20,
  EFP_MagicAttack = 21,
  EFP_PhyHurt = 22,
  EFP_MagicHurt = 23,
  EFP_PhyDefense = 24,
  EFP_MagicDefense = 25,
  EFP_COUNT = 32,
  EFightParam_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EFightParam_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EFightParam_IsValid(int value);
const EFightParam EFightParam_MIN = EFP_None;
const EFightParam EFightParam_MAX = EFP_COUNT;
const int EFightParam_ARRAYSIZE = EFightParam_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFightParam_descriptor();
inline const ::std::string& EFightParam_Name(EFightParam value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFightParam_descriptor(), value);
}
inline bool EFightParam_Parse(
    const ::std::string& name, EFightParam* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFightParam>(
    EFightParam_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)


}  // namespace NetProto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NetProto::ESceneObject> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProto::ESceneObject>() {
  return ::NetProto::ESceneObject_descriptor();
}
template <> struct is_proto_enum< ::NetProto::EMoveAgentState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProto::EMoveAgentState>() {
  return ::NetProto::EMoveAgentState_descriptor();
}
template <> struct is_proto_enum< ::NetProto::EMoveState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProto::EMoveState>() {
  return ::NetProto::EMoveState_descriptor();
}
template <> struct is_proto_enum< ::NetProto::EBattleOperation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProto::EBattleOperation>() {
  return ::NetProto::EBattleOperation_descriptor();
}
template <> struct is_proto_enum< ::NetProto::EFightParam> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetProto::EFightParam>() {
  return ::NetProto::EFightParam_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BattleEnum_2eproto__INCLUDED
